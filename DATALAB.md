1 int bitXor (int x, int y);

函数实现：

```
int bitXor (int x,int y) {
	return (~(x&y))&(~(~x&~y));
}
```

函数分析：

需要实现的操作如下：

```
1 ^ 1 = 0
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
```

只能使用&和~，首先考虑二元运算符&，寻找与运算和异或运算的主要差别。

```
1 & 1 = 1
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
```

如果对x&y的结果按位取反，与目标操作就只有x,y都为0时，产生值与目标结果不一样。

我们发现对于~((x)&(~y))，10和01结果仍为1，11和00结果与x&y相反。那么只需将两次的结果按位与，即可使得10、01结果保持为1，11、00置为0。



2 int tmax (void);

函数实现：

```
int tmax (void) {
	return ~(1<<31);
}
```

函数分析：

在补码表达中，最大正数是“除符号位全为1”的数，又题目要求仅能使用0x00-0xff范围内的数。于是通过1<<31得到只有符号位为1的位表示，按位取反即可。



3 int isEqual (int x, int y);

函数实现：

```
int isEqual (int x,int y) {
	return !(x^y);
}
```

函数分析：

是否相等显然与异或操作有关，一旦相等，所有位均被置0，只需用！，即可使相等时返回1，不等时返回0。



4 int byteSwap (int x, int n, int m) ;

函数实现：

```
int byteSwap (int x, int n, int m) {
	int mask,swap;
	n <<= 3;
	m <<= 3;
	mask = ~((0xff << n)|(0xff << m));
	swap = (0xff & (x >> n)<< m)|(0xff & (x >> m)<<n);
	return (x & mask)|swap;
}
```

函数分析：

实现思路很简单，只是保留不交换的字节，取出要交换的字节并交换。

如何实现呢？

这里引入掩码的概念。掩码是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。简单而言，就是将要保留的位&1，不保留的位&0。

制作掩码的时候注意，一个字节是8位，0xff要移动的位数是(@<<3)。

这里掩码的作用是保留非n和m的字节，所以要在((0xff << n)|(0xff << m))的基础上按位取反。

swap同样运用了掩码，先将第n(m)的字节保存下来，再移动到m(n)字节的位置。

最后将经过掩码mask处理的x与交换后的字节swap进行或操作，正确填充每一个字节的值（引用一个比喻，最后一步类似完形填空，mask的作用就像挖空，swap则是找到正确答案）。



5 int isNonNegative (int x);

函数实现：

```
int isNonNegative (int x) {
	return !(x & (1 << 31));
}
```

函数分析：

这里的目标是取出符号位并判断是1or0。利用掩码仅保留符号位，符号位为0，则用非操作返回1，反之亦成立。

后续函数实现中常常通过判断符号位实现正数和负数操作的区分，操作为(x >> 31)&1。



6 int absVal (int x);

函数实现：

```
int absVal (int x) {
	return (x ^ (x >> 31)) + ((x >> 31) & 1);
}
```

函数分析：

这个函数实现的关键是区分正数和负数的操作，正数不变，负数取反加1。

考虑到可以^0可以使操作数保持不变，^1相当于按位取反，我们可以通过符号位为1或者0，实现正数不变，负数先取反。

同理可知，正数加0，负数加1，即各自加各自的符号位。

注意！关键思路在于，利用符号位的不同可以直接实现if结构对于正负数的判断。



7 int isLess (int x, int y);

函数实现：

```
int isLess (int x, int y) {
	return (!!((x + (~y + 1)) >> 31) & !((x >> 31) ^ (y >> 31)))|(((x >> 31) ^ (y >> 31)) & ((x >> 31) & 1));
}
```

函数分析：

题目要求“当x<y返回1”，则可将其转化为x-y符号位为1时，返回1。

但为避免溢出（正数减负数，负数减正数），需将数值比较分为两种情况。

第一，如果x和y符号位相同，不会发生溢出，只需取x+(~y+1)的符号位即可。

第二，如果x和y符号位不同，则当x符号位为1，y符号位为0时，返回1。

判断x和y符号位是否相同，只需利用(x>>31)^(y>>31)的结果，再进行适当的非运算即可。

将两种情况下的结果按位或，即可覆盖所有情况。



8 int howManyBits (int x);



9 int ilog2 (int x);



10 int addOK (int x, int y);

函数实现：

```
int addOK (int x, int y) {
	return (((x >> 31) & 1)^((y >> 31) & 1)|!(((x >> 31) & 1) ^ (((x + y) >> 31) & 1));
}
```

函数分析：

将加法溢出分为两种情况：

第一，x和y符号位不同，一定不会溢出。

第二，x和y符号位相同，如果x+y符号位和x(y)相同，则未溢出，反之溢出。

通过异或操作判断符号位的相同与否，再根据题目要求辅以适当的非操作即可。

将两种情况下的结果按位或，即可覆盖所有情况。



11 
