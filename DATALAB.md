## 一、实验目的

本实验目的是加强对位级运算的理解及熟练使用的能力。

## 二、函数分析

1 int bitXor (int x, int y);

函数实现：

```
int bitXor (int x,int y) {
	return (~(x&y))&(~(~x&~y));
}
```

函数分析：

需要实现的操作如下：

```
1 ^ 1 = 0
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
```

只能使用&和~，首先考虑二元运算符&，寻找与运算和异或运算的主要差别。

```
1 & 1 = 1
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
```

如果对x&y的结果按位取反，与目标操作就只有x,y都为0时，产生值与目标结果不一样。

我们发现对于~((x)&(~y))，10和01结果仍为1，11和00结果与x&y相反。那么只需将两次的结果按位与，即可使得10、01结果保持为1，11、00置为0。



2 int tmax (void);

函数实现：

```
int tmax (void) {
	return ~(1<<31);
}
```

函数分析：

在补码表达中，最大正数是“除符号位全为1”的数，又题目要求仅能使用0x00-0xff范围内的数。于是通过1<<31得到只有符号位为1的位表示，按位取反即可。



3 int isEqual (int x, int y);

函数实现：

```
int isEqual (int x,int y) {
	return !(x^y);
}
```

函数分析：

是否相等显然与异或操作有关，一旦相等，所有位均被置0，只需用！，即可使相等时返回1，不等时返回0。



4 int byteSwap (int x, int n, int m) ;

函数实现：

```
int byteSwap (int x, int n, int m) {
	int mask;
    n = n << 3;
    m = m << 3;
    mask = ((x >> n) ^ (x >> m)) & 0xFF;
    return x ^ (mask << n) ^ (mask << m);
}
```

函数分析：

实现思路很简单，只是保留不交换的字节，取出要交换的字节并交换。

如何实现呢？

这里引入掩码的概念。掩码是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。简单而言，就是将要保留的位&1，不保留的位&0。

（制作掩码的时候注意，一个字节是8位，0xff要移动的位数是(@<<3)。）

利用掩码最直观的想法是将直接用0xff左移相应位数，保留不交换或者要交换的字节，最后利用按位或操作把交换了的两个字节和保留的不交换字节组合成为答案。但这种算法会额外地增加“将需交换的字节清零”的操作，我们可以利用下述异或操作的性质直接制作可以直接将需交换的字节变为目标字节的掩码。

```
(1 ^ 0) ^ 1 = 0
(0 ^ 1) ^ 0 = 0
```

用通俗的语言来说，异或操作可以保留两个数字之间是否相同的信息，利用m字节和n字节异或操作保留的信息，可以直接将m字节和n字节的值交换。



5 int isNonNegative (int x);

函数实现：

```
int isNonNegative (int x) {
	return !(x >> 31);
}
```

函数分析：

这里的目标是取出符号位并判断是1or0，非1则为非负。

如果符号位为0，则x << 31为全0，直接进行非操作即可返回1。

后续函数实现中常常通过判断符号位实现正数和负数操作的区分，操作为(x >> 31)&1。



6 int absVal (int x);

函数实现：

```
int absVal (int x) {
	int temp = x >> 31;
    return (x^temp)+(temp&1);
}
```

函数分析：

这个函数实现的关键是区分正数和负数的操作，正数不变，负数取反加1。

考虑到可以^0可以使操作数保持不变，^1相当于按位取反，我们可以通过符号位为1或者0，实现正数不变，负数先取反。

同理可知，正数加0，负数加1，即各自加各自的符号位。

注意！关键思路在于，利用符号位的不同可以直接实现if结构对于正负数的判断。

本题简化操作数的关键在于利用数学定律化简，如下：

```
int absVal (int x) {
	int temp = x >> 31;
	return (x + temp) ^ temp;
}
```



7 int isLess (int x, int y);

函数实现：

```
int isLess (int x, int y) {
	int temp = x ^ y;
    int m = x + ~y + 1;
    return (((m & ~temp) + (x & temp)) >> 31) & 1 ;
}
```

函数分析：

题目要求“当x<y返回1”，则可将其转化为x-y符号位为1时，返回1。

但为避免溢出（正数减负数，负数减正数），需将数值比较分为两种情况。

第一，如果x和y符号位相同，不会发生溢出，只需取x+(~y+1)的符号位即可。

第二，如果x和y符号位不同，则当x符号位为1，y符号位为0时，返回1。

判断x和y符号位是否相同，只需利用(x>>31)^(y>>31)的结果，再进行适当的非运算即可。

将两种情况下的结果按位或，即可覆盖所有情况。



8 int howManyBits (int x);

函数实现：

```
int howManyBits (int x) {
    int temp = x ^ (x << 1); //找出最高位1
    int bit_16,bit_8,bit_4,bit_2,bit_1;
    bit_16 = !!(temp >> 16) << 4; //如果temp>>16不为0，则最高位1在高16位中，将偏移量记为16
    temp = temp >> bit_16; //右移16位，去除低16位的影响
    bit_8 = !!(temp >> 8) << 3; //以此类推，判别最高位1是否在高八位中
    temp = temp >> bit_8;
    bit_4 = !!(temp >> 4) << 2;
    temp = temp >> bit_4;
    bit_2 = !!(temp >> 2) << 1;
    temp = temp >> bit_2;
    bit_1 = !!(temp >> 1);
    return 1 + bit_1 + bit_2 + bit_4 + bit_8 + bit_16;//将分步得到的偏移量求和，再加上最高位1，则得到结果
}
```

函数分析：

先利用x^(x<<1)将x中相邻位不同的位置标记为1，确定最高位1的位置；在用二分查找，依次检查高 16 位、高 8 位、高 4 位、高 2 位和最高位是否有 1，并根据检查结果确定相应的偏移量；最后将所有bit_n求和，再加上最高位1.得到表示x所需的最少二进制位数。具体见注释。



9 int ilog2 (int x);

函数实现：

```
int ilog2 (int x) {
  int bit_16,bit_8,bit_4,bit_2,bit_1;
  bit_16 = (!!(x >> 16)) << 4;  //如果高16位有1，则接下来需要右移16位继续判断高8位是否有1，反之，接下来会判断低16位的高8位
  bit_8 = bit_16 + ((!!(x >> (bit_16 + 8))) << 3); //以此类推，每次都需要累积以前一计算的偏移量
  bit_4 = bit_8 + ((!!(x >> (bit_8 + 4))) << 2);
  bit_2 = bit_4 + ((!!(x >> (bit_4 + 2))) << 1);
  bit_1 = bit_2 + (!!(x >> (bit_2 + 1)));
  return bit_1;
}
```

函数分析：

ilog2函数的结果其实就是找出x位表达中最高位1所在的位置。同样利用二分查找，思路与howmanybits相同。具体见注释。



10 int addOK (int x, int y);

函数实现：

```
int addOK (int x, int y) {
  return ((x ^ y)|~((x + y) ^ x)) >> 31 & 1;
}
```

函数分析：

将加法溢出分为两种情况：

第一，x和y符号位不同，一定不会溢出。

第二，x和y符号位相同，如果x+y符号位和x(y)相同，则未溢出，反之溢出。

通过异或操作判断符号位的相同与否，再根据题目要求辅以适当的非操作即可。

将两种情况下的结果按位或，即可覆盖所有情况。



11 int multFiveEighths (int x);

函数实现：

```
int multFiveEighths (int x) {
  return ((x << 2)+ x +((x >> 31) & 7)) >> 3;
}
```

函数分析：

本题的关键是“向0舍入”，翻开课本P73 ，根据数学推导，我们只需对于负数特判，加上一个2^k-1即可（k为除数对应右移的二进制位数）。

虽然直接按课本结论操作即可，但我们还是来简单理解一下为何偏移量是2^k-1。

以本题为例，除以8时，从低位向高位数，第四位开始可以整除，那么需要舍入的就是剩下的三位。

当x为正数，本就向0舍入；当x位负数，末三位十进制值不为0，则必需舍入，为使其向大舍入，我们需要加一个数，使得无论末三位为何，x/8的绝对值都少进一位。末三位的绝对值最多到-7，若加上7，则末三位的值从-7~0被修正为0~7，而(0~7)/8必为0，这样x/8的绝对值就少进一位了。

再结合“位运算组合实现乘法”即可实现该函数。



12 int trueThreeFourths (int x);

函数实现：

```
int trueThreeFourths (int x)
{
  return (~((x >> 2)+((((x & 3) + 3)&(~(x >> 31))) >> 2)) + 1) + x;
}
```

函数分析：

本题与上一题思路相同，唯一不同的是需要避免溢出带来的错误结果。

先乘3可能直接就溢出了，那么可以考虑“曲线”计算出x*3/4，即x - x / 4。



13 unsigned float_neg (unsigned uf);

函数实现：

```
unsigned float_neg (unsigned uf) {
  if((uf & 0x7fffffff) > 0x7f800000) return uf;
  return uf ^ 0x80000000;
}
```

函数分析：

本题最直观的思路是直接根据浮点数表示的规则，通过移位和异或直接找出NaN并返回，其余的改变符号位即可。

为优化操作数，选择采用大数字直接比对。已知exp全1，frac非全0即为NaN，则去除符号位影响后，直接与0x7f800000比较大小即可。

判断非NaN，则直接返回仅改变符号位的结果。



14 int float_f2i (unsigned uf);

函数实现：

```
int float_f2i(unsigned uf) {
  int s,exp,res;
  s = uf & 0x80000000; //s
  exp = (uf & 0x7f800000) >> 23; //exp
  res = uf & 0xffffff; //frac
  if (exp >= 158) return 0x80000000u; //158 = 127 + 31，即e大于31，超出有符号整型表示范围，直接返回0x80000000u
  if (exp < 127) return 0; //127 = 0 + 127，即e小于0时，对应整型必为0
  if (exp >= 150) res <<= (exp - 150);
  else res >>= (150 - exp); //150 = 127 + 23，即e不为23时，不能直接返回frac的位模式，而是应该放大/缩小相应的倍数
  if (s) return -res; //处理符号位
  return res;
}
```

函数分析：

![img](https://wdxtub.com/images/csapp/14609515849125.jpg)

对于浮点数转有符号整型，谨遵规则即可。规则作为注释附于函数内部了。

注意不要忘记偏移量！

注意有符号整型和浮点数的表示范围不同，并不能仅仅考虑非规格化值！



15 unsigned float_half (unsigned uf);

函数实现：

```
unsigned float_half (unsigned uf) {
  int s = uf & 0x80000000; //s
  int exp = uf & 0x7f800000; //exp
  int lsb = ((uf & 3) == 3); //判断末两位是否为1，如果末两位均为1，则需考虑舍入
  if (exp == 0x7f800000)
	  return uf; //exp全1，frac非全0时，为NaN，直接返回uf；exp全1，frac全0时，为无穷，返回uf
  else if (exp <= 0x800000)
	  return s | (((uf ^ s) + lsb) >> 1); //向偶数舍入
  else return uf - 0x800000; //exp-1，相当于少乘一个2，即uf除以2
}
```

函数分析：

还是根据浮点数规则处理即可。

除开NaN和无穷，可将除以2分为两种情况。

其一，可通过exp-1直接除2；

其二，exp为全0或者1，已经达到下限，无法直接通过exp-1除2，需要将frac右移一位，注意考虑舍入！



16 unsigned float_twice (unsigned uf);

函数实现：

```
unsigned float_twice (unsigned uf) {
  int exp = uf & 0x7f800000; //exp
  if(!exp)
  uf = (((uf & 0x7fffff) << 1) | (uf & 0x80000000));
  else if(exp ^ 0x7f800000)
  uf += 0x00800000;
  return uf;
}
```

函数分析：

根据浮点数规则，可以将浮点数翻倍分为以下三种情况：

当exp全0时，其值由尾数部分决定。将尾数部分左移一位，相当于将该浮点数乘以 2。同时，通过按位与操作保留原浮点数的符号位，最后将左移后的尾数部分和符号位按位或，得到新的浮点数表示。

当exp全1时，直接返回uf。

当exp不全为1时，则exp+1即可实现浮点数乘以2。



17 int bang (int x);

函数实现：

```
int bang (int x) {
  return ((x | (~x + 1)) >> 31) + 1;
}
```

函数分析：

本题需利用非！操作符实现！，考虑！的作用，我们明白解题的关键在于找出0和其他所有有符号整型数的共同差别，利用其将0和其他所有数区分开。

我们很快想到只有0——相反数的符号位与原符号位相同！

当你沾沾自喜地提交 "return ~(x ^ (~x + 1)  >> 31) & 1"时就会惊喜地发现0x80000000无法通过！

恭喜你掉进了陷阱！！！

从此你吸取了教训，不管哪一题都得考虑溢出的问题——0x80000000取反加一还是0x80000000！

考虑到这一点，你现在只需要找到0和0x80000000的不同就可以了，那就是一个符号位为0，一个为1。但是另外增加一步判断符号位显然是划不来的，我们希望找到统一的逻辑。回忆一下究竟哪个操作符的两种运算结果数目比例为3：1呢？

是|！巧合的是，它正好比异或操作多的一种情况就是1 | 1 = 1。

那么我们只需将抑或操作改为按位或，就可以使用统一的逻辑区分0和非0的数了。



18 int copyLSB (int x);

函数实现：

```
int copyLSB (int x) {
  return x << 31 >> 31;
}
```

函数分析：

先左移31位，将最低位置为符号位，再右移31位，利用算术右移的性质复制符号位。



19 int bitCount(int x);

函数实现：

```
int bitCount (int x) {
    int temp = 0x11 | (0x11 << 8);
    int mask = temp | (temp << 16);

    int brd = x & mask;
    brd += x>>1 & mask;
    brd += x>>2 & mask;
    brd += x>>3 & mask;

    brd = brd + (brd >> 16);

    mask = 0xF | (0xF << 8);
    brd = (brd & mask) + ((brd >> 4) & mask);
    return (brd + (brd >> 8)) & 0x3F;
}
```

函数分析：

（这是个人认为最困难的一题）

采用分治，利用特殊掩码 `0x11111111`，将 32 位整数 `x` 按每 4 位一组进行划分。通过将 `x` 右移不同位数后与掩码按位与，并累加到 `brd` 上，实现对每 4 位中 1 的个数的统计。此时 `brd` 中每 4 位存储了原 `x` 对应 4 位中 1 的个数。将 `brd` 右移 16 位后与自身相加，把高 16 位和低 16 位中 1 的个数进行合并。再利用掩码 `0x0F0F`，将 `brd` 与掩码按位与，加上 `brd` 右移 4 位后与掩码按位与的结果，进一步合并每 8 位中 1 的个数。 `brd` 加上 `brd` 右移 8 位的结果，并与 `0x3F` 按位与，得到最终 32 位整数中 1 的总个数。



20 int isAsciiDigit (int x);

函数实现：

```
int isAsciiDigit (int x) {
  int temp1 = !((x >> 1) ^ 0x1c);
  int temp2 = !((x >> 3) ^ 0x6);   
  return temp1 | temp2;
}
```

函数分析：

本题的目标是判断x是否在 0x30 - 0x39 的范围内。

分析这些数的位表示。

```
0011 0000
0011 0001
0011 0010
0011 0011
0011 0100
0011 0101
0011 0110
0011 0111
0011 1000
0011 1001
```

我们发现当高字节为0...011时，若最低字节的最高位为0，则x符合题意。但由于要判断的位数多于一位，我们必须使用异或操作。由于该情况下，末三位的取值无关紧要，我们通过右移3位去除它们对于异或操作结果的影响，又算术右移的符号位必为0，不会对异或操作结果产生影响。

当高字节为0...011时，若最低字节的最高位为1，则只有当倒数2、3位均为0时，x符合题意。与第一种情况的思路相同，我们同样通过异或操作判断除末位的所有位是否符合要求。

上述两种情况覆盖了所有可能，则只要满足其中一种情况，即可返回1.



## 三、实验总结

几个关键：符号位、边界条件、表示规则

几个重要工具：掩码、二分查找、分治思想

一个关键想法：利用位运算实现分支结构

完成题目时首先要考虑的是符号位和位模式规则，其次是边界条件，多数题目需要考虑溢出情况，如果不能使用统一逻辑判断，很可能需要对边界条件特判。特判无疑需要使用分支结构，比如if-else，那么关键就在于如何用运算符实现条件判断。这里就是结合符号位实现的，例如absval中，当temp全1时，才取反加1。

题目中最常用的方法就是掩码，取出特定的位进行判断和计算，其次是二分查找，可以大幅降低操作数。虽然bitcount的关键之一是使用分治思想，但是个人认为更重要的是制作特殊掩码。
